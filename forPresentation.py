# -*- coding: utf-8 -*-
"""
/***************************************************************************
 seasonDistance
                                 A QGIS plugin
 Calculates Owls Season Distance
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-07-09
        git sha              : $Format:%H$
        copyright            : (C) 2018 by University of Muenster
        email                : b_teka02@uni-muenster.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction
import os
import math
from qgis.core import *
import qgis.utils
from datetime import datetime
from decimal import Decimal
import numpy as np
import matplotlib.pyplot as plt



# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .owls_season_distance_dialog import seasonDistanceDialog
import os.path


class seasonDistance:
    """QGIS Plugin Implementation."""
    uniqueOwls = [0,0,0,0];
    speedSum = [0,0,0,0]
    coordinatesX = [0,0,0,0];
    coordinatesY = [0,0,0,0];
    distanceCovered=[0,0,0,0];
    previousDistance=[0,0,0,0];
    owlsType = [0,0,0,0]
    tags = []
    Seasons = ['Winter','Spring','Summer','Autumn']
    seasonsText=[]
    sumV = [0,0,0,0]
    sd=[0,0,0,0]
    meanSpeed=[0,0,0,0]
    normalizedDistance=[0,0,0,0]
    startTimeStamp=['','','','']
    endTimeStamp=['','','','']
    countTrigger=[0,0,0,0]
    distanceByMonth=[0,0,0,0,0,0,0,0,0,0,0,0]
    twoD=[]
    months=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']
    distance2011=[0,0,0,0]
    distance2012=[0,0,0,0]
    distance2013=[0,0,0,0]
    distance2014=[0,0,0,0]
    distance2015=[0,0,0,0]
    distance2016=[0,0,0,0]
    distance2017=[0,0,0,0]
    #For Months standard deviation
    distanceMonth2011=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2012=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2013=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2014=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2015=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2016=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2017=[0,0,0,0,0,0,0,0,0,0,0,0]
    meanMonthCount = [0,0,0,0,0,0,0,0,0,0,0,0]
    sdMonthly = [0,0,0,0,0,0,0,0,0,0,0,0]
    normalizedMonthlyDistance=[0,0,0,0,0,0,0,0,0,0,0,0]
    #We don't know for what
    uniqueOwls2011=[0,0,0,0]
    uniqueOwls2012=[0,0,0,0]
    uniqueOwls2013=[0,0,0,0]
    uniqueOwls2014=[0,0,0,0]
    uniqueOwls2015=[0,0,0,0]
    uniqueOwls2016=[0,0,0,0]
    uniqueOwls2017=[0,0,0,0]
    meanDistance = [0,0,0,0]
    meanCount = [0,0,0,0]
    tagsJan=[]
    tagsFeb=[]
    tagsMar=[]
    tagsApr=[]
    tagsMay=[]
    tagsJun=[]
    tagsJul=[]
    tagsAug=[]
    tagsSept=[]
    tagsOct=[]
    tagsNov=[]
    tagsDec=[]
    uniqueOwlsMonth=[0,0,0,0,0,0,0,0,0,0,0,0]
    tags2011=[]
    tags2012=[]
    tags2013=[]
    tags2014=[]
    tags2015=[]
    tags2016=[]
    tags2017=[]
    seasonsIndex = [0,1,2,3]
    monthsIndex = [0,1,2,3,4,5,6,7,8,9,10,11]
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'seasonDistance_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = seasonDistanceDialog()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Owls Season Distance')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'seasonDistance')
        self.toolbar.setObjectName(u'seasonDistance')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('seasonDistance', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/owls_season_distance/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Browse'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Owls Season Distance'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    
    def run(self):
        self.dlg.comboBox.clear()
        #print("here")
        layers = self.iface.mapCanvas().layers()
        layers_list = []
        for layer in layers:
            layers_list.append(layer.name());
        self.dlg.comboBox.addItems(layers_list);
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        tagsOneEach = ['1751', '1750', '1292', '1753', '1754', '3896', '3895', '3894', '3897', '3898', '4045', '5159', '4044', '3899', '5158', '4046', '4043', '4846', '3893', '3892', '4848']
        #tagsOneEach = ['1751', '1754', '4043', '4848']
        seasonsUnique = ['spring', 'spring', 'spring', 'spring', 'summer', 'summer', 'summer', 'summer', 'spring', 'spring', 'spring', 'spring', 'spring', 'spring', 'spring', 'spring', 'winter', 'summer', 'summer', 'summer', 'autumn']
        #seasonsUnique = ['spring','summer', 'winter', 'autumn']
        if result:
            layer = layers[self.dlg.comboBox.currentIndex()]
            features = layer.getFeatures();
            for i in range(len(tagsOneEach)):
                expression = QgsExpression("tag_ident = '"+tagsOneEach[i]+"'");
                request = QgsFeatureRequest(expression)
                selection = layer.getFeatures(request)
                self.distanceCalculation(selection)
                
                
                #print('done')
            #out_attributes = layer.GetLayerDefn()
            #fo
            #print(out_attributes.GetFieldCount());

            self.normalizedDistance = [x/y for x, y in zip(self.distanceCovered, self.uniqueOwls)]
            
            
            print(self.distanceByMonth);
            self.normalizedMonthlyDistance = [x/y for x, y in zip(self.distanceByMonth, self.uniqueOwlsMonth)]
            self.calculateMean();
            self.calculateSD();
            self.calculateMeanMonthly();
            self.calculateSDMonthly();
            self.distancePlot(self.Seasons,self.normalizedDistance,self.sd, self.months, self.normalizedMonthlyDistance,self.sdMonthly)
            #self.distanceSeasonPlot(self.Seasons,self.normalizedDistance);
            #self.distanceMonthsPlot(self.distanceByMonth,self.months);
            
            #print(self.distanceMonth2011)
            #print(self.distanceMonth2012)
            #print(self.distanceMonth2013)
            #print(self.distanceMonth2014)
            #print(self.distanceMonth2015)
            #print(self.distanceMonth2016)
            #print(self.distanceMonth2017)
            
    def distancePlot(self,seasons,distanceSeasons,seasonalSd, months,distancMonthly,sdMonthly):
        print('Seasonly')
        print(seasons)
        print(distanceSeasons)
        print(seasonalSd)
        print('Number of recordings')
        print(self.owlsType)
        print('Monthly')
        print(months)
        print(distancMonthly)
        print('Monthly SD')
        print(sdMonthly)
        
        
            distanceMonth2011=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2012=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2013=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2014=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2015=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2016=[0,0,0,0,0,0,0,0,0,0,0,0]
    distanceMonth2017=[0,0,0,0,0,0,0,0,0,0,0,0]
        for [[x in range(distanceMonth2011)] for x in xrange(6)]
        
        #y_pos = np.arange(len(seasons))
        #width = 0.35       # the width of the bars: can also be len(x) sequence
        distanceSeasons= [x / 1000 for x in distanceSeasons]
        seasonalSd=[x / 1000 for x in seasonalSd]
        distancMonthly= [x / 1000 for x in distancMonthly]
        sdMonthly=[x / 1000 for x in sdMonthly]
        #p1 = plt.bar(y_pos, distanceSeasons, width, color='#d62728')
        #p2 = plt.bar(y_pos, seasonalSd, width,bottom=distanceSeasons)

        #plt.ylabel('Distance')
        #plt.title('Owls Seasonal average distance & Standard Deviation')
        #plt.xticks(y_pos, seasons)
        #plt.yticks(distanceSeasons)
        #plt.legend((p1[0], p2[0]), ('Average Distance', 'Standard Deviation'))
        
        fig, ax1 = plt.subplots()
        ax2 = ax1.twinx()
        xn = range(len(seasons))
        ax1.plot(xn, distanceSeasons, 'g-')
        ax2.plot(xn, seasonalSd, 'b-')
        ax1.set_xlabel('Seasons')
        ax1.set_ylabel('Distance in seasons', color='g')
        ax2.set_ylabel('Standard Deviation', color='b')
        plt.xticks(xn, seasons)
        ax1.legend()
        ax2.legend()
        plt.title('Average distance covered by Owl per season against Standard Deviation')
        plt.show()
        
        fig, ax3 = plt.subplots()
        ax4 = ax3.twinx()
        xn = range(len(months))
        ax3.plot(xn, distancMonthly, 'g-')
        ax4.plot(xn, sdMonthly, 'b-')
        ax3.set_xlabel('Months')
        ax3.set_ylabel('Distance in months', color='g')
        ax4.set_ylabel('Standard Deviation in months', color='b')
        plt.xticks(xn, months)
        ax3.legend()
        ax4.legend()
        plt.title('Average distance covered by Owl per month against Standard Deviation')
        plt.show()
        #p3 = plt.bar(y_pos, distancMonthly, width, color='#D5D8DC')
        #p4 = plt.bar(y_pos, sdMonthly, width,bottom=distancMonthly)
        #y_pos = np.arange(len(months))
        #plt.xticks(y_pos, months)
        #plt.legend((p3[0], p4[0]), ('Average Distance', 'Standard Deviation'))
        #plt.ylabel('Distance')
        #plt.title('Owls monthly average distance of owl flight in every month')
        #plt.show()
        
    def calculateMeanMonthly(self):
        counter = -1
        for one,two,three,four,five,six,seven in zip(self.distanceMonth2011,self.distanceMonth2012,self.distanceMonth2013,self.distanceMonth2014,self.distanceMonth2015,self.distanceMonth2016,self.distanceMonth2017):
            counter = counter+1
            if one!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
            if two!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
            if three!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
            if four!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
            if five!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
            if six!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
            if seven!=0:
               self.meanMonthCount[counter] = self.meanMonthCount[counter] + 1
        print(self.meanMonthCount)
    def calculateMean(self):
        counter = -1
        for one,two,three,four,five,six,seven in zip(self.distance2011,self.distance2012,self.distance2013,self.distance2014,self.distance2015,self.distance2016,self.distance2017):
            counter = counter+1
            if one!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
            if two!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
            if three!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
            if four!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
            if five!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
            if six!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
            if seven!=0:
               self.meanCount[counter] = self.meanCount[counter] + 1
    def calculateSD(self):
        meanDistance = [x/y for x, y in zip(self.distanceCovered, self.meanCount)]
        for i in range(4):
            self.sd[i] = math.sqrt(((self.distance2011[i] - meanDistance[i])**2 + (self.distance2012[i] - meanDistance[i])**2 + (self.distance2013[i] - meanDistance[i])**2 + (self.distance2014[i] - meanDistance[i])**2 + (self.distance2015[i] - meanDistance[i])**2 + (self.distance2016[i] - meanDistance[i])**2 + (self.distance2017[i] - meanDistance[i])**2)/self.meanCount[i])
        print('Standard Deviation of distance with in season')
        print(self.sd)
    def calculateSDMonthly(self):
        meanMonthDistance = [x/y for x, y in zip(self.distanceByMonth, self.meanMonthCount)]
        for i in range(12):
            self.sdMonthly[i] = math.sqrt(((self.distanceMonth2011[i] - meanMonthDistance[i])**2 + (self.distanceMonth2012[i] - meanMonthDistance[i])**2 + (self.distanceMonth2013[i] - meanMonthDistance[i])**2 + (self.distanceMonth2014[i] - meanMonthDistance[i])**2 + (self.distanceMonth2015[i] - meanMonthDistance[i])**2 + (self.distanceMonth2016[i] - meanMonthDistance[i])**2 + (self.distanceMonth2017[i] - meanMonthDistance[i])**2)/self.meanMonthCount[i])
        print('Standard Deviation of distance with in month')
        print(self.sdMonthly)
    def distanceMonthsPlot(self,distance,months):
        #print('Monthly')
        #print(months)
        #print(distance)
        #print('Yearly')
        #print(self.distance2011)
        #print(self.distance2012)
        #print(self.distance2013)
        #print(self.distance2014)
        #print(self.distance2015)
        #print(self.distance2016)
        #print(self.distance2017)
        #print('unique owls')
        #print(self.uniqueOwls2011)
        #print(self.uniqueOwls2012)
        #print(self.uniqueOwls2013)
        #print(self.uniqueOwls2014)
        #print(self.uniqueOwls2015)
        #print(self.uniqueOwls2016)
        #print(self.uniqueOwls2017)

        #averageDistanceYears=
        #print(self.owlsType)
        y_pos = np.arange(len(months))
        plt.bar(y_pos, distance, align='center', alpha=0.5)
        plt.xticks(y_pos, months)
        plt.ylabel('Distance')
        plt.title('Average distance of owl flight in every month')
        plt.show()

    def calculateDistance(self,lat1,lon1,lat2,lon2):
        dlat=(lat2-lat1)**2
        dlon=(lon2-lon1)**2
        distance=math.sqrt(dlat + dlon);
        return distance; 
    def calculateDistanceWGS84(self,lat1,lon1,lat2,lon2):
        earth_radius = 6371;
        pi = 0.017453292519943295; 
        dlat=(lat2-lat1)*pi
        dlon=(lon2-lon1)*pi
        distance=(math.sin(dlat/2)*math.sin(dlat/2)) + (math.cos(lat1*pi)*math.cos(lat2*pi)*math.sin(dlon/2)*math.sin(dlon/2));
        distance = np.clip(distance, -1, 1)
        #print(distance)
        distance = 2 * math.atan2(math.sqrt(distance), math.sqrt(1 - distance));
        #distance = 2 * asin(sqrt(distance));
        #distance=math.acos(distance);
        distance=distance*earth_radius;
        #print(distance)
        return distance; 

    def perYearMonth(self,date_year,month_id,distanceCalculated):
        if date_year == 2011:
            self.distanceMonth2011[month_id] = distanceCalculated + self.distanceMonth2011[month_id];
        elif date_year == 2012:
            self.distanceMonth2012[month_id] = distanceCalculated + self.distanceMonth2012[month_id];
        elif date_year == 2013:
            self.distanceMonth2013[month_id] = distanceCalculated + self.distanceMonth2013[month_id];
        elif date_year == 2014:
            self.distanceMonth2014[month_id] = distanceCalculated + self.distanceMonth2014[month_id];
        elif date_year == 2015:
            self.distanceMonth2015[month_id] = distanceCalculated + self.distanceMonth2015[month_id];
        elif date_year == 2016:
            self.distanceMonth2016[month_id] = distanceCalculated + self.distanceMonth2016[month_id];
        elif date_year == 2017:
            self.distanceMonth2017[month_id] = distanceCalculated + self.distanceMonth2017[month_id];

    def perYear(self,date_year,seasonIn,distanceCalculated):
        if date_year == 2011:
            self.distance2011[seasonIn] = distanceCalculated + self.distance2011[seasonIn];
        elif date_year == 2012:
            self.distance2012[seasonIn] = distanceCalculated + self.distance2012[seasonIn];
        elif date_year == 2013:
            self.distance2013[seasonIn] = distanceCalculated + self.distance2013[seasonIn];
        elif date_year == 2014:
            self.distance2014[seasonIn] = distanceCalculated + self.distance2014[seasonIn];
        elif date_year == 2015:
            self.distance2015[seasonIn] = distanceCalculated + self.distance2015[seasonIn];
        elif date_year == 2016:
            self.distance2016[seasonIn] = distanceCalculated + self.distance2016[seasonIn];
        elif date_year == 2017:
            self.distance2017[seasonIn] = distanceCalculated + self.distance2017[seasonIn];
   
    def perYearUnique(self,date_year,seasonIn,tag_ident):
        if date_year == 2011:
            if tag_ident not in self.tags2011:
                    self.uniqueOwls2011[seasonIn] = self.uniqueOwls2011[seasonIn]+ 1
                    self.tags2011.append(tag_ident)
        elif date_year == 2012:
            if tag_ident not in self.tags2012:
                    self.uniqueOwls2012[seasonIn] = self.uniqueOwls2012[seasonIn]+ 1
                    self.tags2012.append(tag_ident)
        elif date_year == 2013:
            if tag_ident not in self.tags2013:
                    self.uniqueOwls2013[seasonIn] = self.uniqueOwls2013[seasonIn]+ 1
                    self.tags2013.append(tag_ident)
        elif date_year == 2014:
            if tag_ident not in self.tags2014:
                    self.uniqueOwls2014[seasonIn] = self.uniqueOwls2014[seasonIn]+ 1
                    self.tags2014.append(tag_ident)
        elif date_year == 2015:
            if tag_ident not in self.tags2015:
                    self.uniqueOwls2015[seasonIn] = self.uniqueOwls2015[seasonIn]+ 1
                    self.tags2015.append(tag_ident)
        elif date_year == 2016:
            if tag_ident not in self.tags2016:
                    self.uniqueOwls2016[seasonIn] = self.uniqueOwls2016[seasonIn]+ 1
                    self.tags2016.append(tag_ident)
        elif date_year == 2017:
            if tag_ident not in self.tags2017:
                    self.uniqueOwls2017[seasonIn] = self.uniqueOwls2017[seasonIn]+ 1
                    self.tags2017.append(tag_ident)
    def checkUniqueMonthly(self,tag_ident,monthId):
        if monthId == 0:
            if tag_ident not in self.tagsJan:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsJan.append(tag_ident)
        elif monthId == 1:
            if tag_ident not in self.tagsFeb:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsFeb.append(tag_ident)
        elif monthId == 2:
            if tag_ident not in self.tagsMar:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsMar.append(tag_ident)
        elif monthId == 3:
            if tag_ident not in self.tagsApr:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsApr.append(tag_ident)
        elif monthId == 4:
            if tag_ident not in self.tagsMay:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsMay.append(tag_ident)
        elif monthId == 5:
            if tag_ident not in self.tagsJun:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsJun.append(tag_ident)
        elif monthId == 6:
            if tag_ident not in self.tagsJul:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsJul.append(tag_ident)
        elif monthId == 7:
            if tag_ident not in self.tagsAug:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsAug.append(tag_ident)
        elif monthId == 8:
            if tag_ident not in self.tagsSept:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsSept.append(tag_ident)
        elif monthId == 9:
            if tag_ident not in self.tagsOct:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsOct.append(tag_ident)
        elif monthId == 10:
            if tag_ident not in self.tagsNov:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsNov.append(tag_ident)
        elif monthId ==11:
            if tag_ident not in self.tagsDec:
                    self.uniqueOwlsMonth[monthId] = self.uniqueOwlsMonth[monthId]+ 1
                    self.tagsDec.append(tag_ident)            
    def performComputation(self,selected_features):
        counter = 0;
        pnt_prev_x=[0,0,0,0];
        pnt_prev_y=[0,0,0,0];
        pnt_intial_x=0;
        pnt_intial_y=0;
        for feat in selected_features:
            pnt_intial_x=feat['utm_east'];
            pnt_intial_y=feat['utm_north'];
            break;
        for feature in selected_features:

            tag_timestamp = feature['timestamp']
            tag_ident = feature['tag_ident']
            speed = feature['speed']
            pnt_now= feature.geometry();
            dt = datetime.strptime(tag_timestamp, '%Y-%m-%d %H:%M:%S')
            pnt_now_x=feature['utm_east'];
            pnt_now_y=feature['utm_north'];
            #print(str(pnt_now_x) + ","+ str(pnt_now_y))
            date_year = dt.year;
            date_day = dt.month+dt.day/30
            #print(tag_timestamp)
            #print(pnt_now_x)
            #print(self.coordinatesX)
            #print(pnt_now_y)
            #print(self.coordinatesY)
            
            if date_day >= 6.7 and date_day <=9.7: #Summer
                self.owlsType[2] = self.owlsType[2]+1
                self.coordinatesX[2] = pnt_now_x;
                self.coordinatesY[2] = pnt_now_y;
                if pnt_prev_x[2]==0:
                    pnt_prev_x[2]=pnt_intial_x;
                    pnt_prev_y[2]=pnt_intial_y;
                else:
                    distanceCalculated = self.calculateDistance(pnt_prev_x[2],pnt_prev_y[2],self.coordinatesX[2],self.coordinatesY[2]);
                    self.perYear(date_year,2,distanceCalculated)
                    self.perYearUnique(date_year,2,tag_ident)
                    self.distanceByMonth[dt.month-1] = self.distanceByMonth[dt.month-1] + distanceCalculated;
                    self.checkUniqueMonthly(tag_ident,dt.month-1);
                    self.perYearMonth(date_year,dt.month-1,distanceCalculated)
                    #print(((self.coordinatesX[2]-pnt_prev_x[2])*(self.coordinatesX[2]-pnt_prev_x[2]))+((self.coordinatesY[2]-pnt_prev_y[2])*(self.coordinatesY[2]-pnt_prev_y[2])))
                    self.distanceCovered[2]=self.distanceCovered[2]+distanceCalculated
                    pnt_prev_x[2]=self.coordinatesX[2];
                    pnt_prev_y[2]=self.coordinatesY[2];
                if tag_ident not in self.tags:
                    self.uniqueOwls[2] = self.uniqueOwls[2]+1;
                    self.tags.append(tag_ident)
                    self.seasonsText.append('summer')
                self.speedSum[2] = self.speedSum[2] + speed
            elif date_day >12.6 or (date_day>=1 and date_day<3.6): #Winter
                if self.startTimeStamp[0] == '':
                    self.startTimeStamp[0]=tag_timestamp;
                else:
                    self.endTimeStamp[0]=tag_timestamp;
                self.owlsType[0] = self.owlsType[0]+1
                self.coordinatesX[0] = pnt_now_x;
                self.coordinatesY[0] = pnt_now_y;
                if pnt_prev_x[0]==0:
                    pnt_prev_x[0]=pnt_intial_x;
                    pnt_prev_y[0]=pnt_intial_y;
                else:
                    distanceCalculated = self.calculateDistance(pnt_prev_x[0],pnt_prev_y[0],self.coordinatesX[0],self.coordinatesY[0]);
                    self.perYearUnique(date_year,0,tag_ident)
                    self.perYear(date_year,0,distanceCalculated)
                    self.distanceByMonth[dt.month-1] = self.distanceByMonth[dt.month-1] + distanceCalculated;
                    self.checkUniqueMonthly(tag_ident,dt.month-1);
                    self.perYearMonth(date_year,dt.month-1,distanceCalculated)
                    #print(((self.coordinatesX[0]-pnt_prev_x[0])*(self.coordinatesX[0]-pnt_prev_x[0]))+((self.coordinatesY[0]-pnt_prev_y[0])*(self.coordinatesY[0]-pnt_prev_y[0])))
                    self.distanceCovered[0]=self.distanceCovered[0]+distanceCalculated
                    pnt_prev_x[0]=self.coordinatesX[0];
                    pnt_prev_y[0]=self.coordinatesY[0];
                if tag_ident not in self.tags:
                    self.uniqueOwls[0] = self.uniqueOwls[0]+ 1
                    self.tags.append(tag_ident)
                    self.seasonsText.append('winter')
                self.speedSum[0] = self.speedSum[0] + speed
            elif (date_day >=3.6 and date_day <6.7): #Spring
                if self.startTimeStamp[1] == '':
                    self.startTimeStamp[1]=tag_timestamp;
                else:
                    self.endTimeStamp[1]=tag_timestamp;
                self.owlsType[1] = self.owlsType[1]+1
                self.coordinatesX[1] = pnt_now_x;
                self.coordinatesY[1] = pnt_now_y;
                if pnt_prev_x[1]==0:
                    pnt_prev_x[1]=pnt_intial_x;
                    pnt_prev_y[1]=pnt_intial_y;
                else:
                    distanceCalculated = self.calculateDistance(pnt_prev_x[1],pnt_prev_y[1],self.coordinatesX[1],self.coordinatesY[1]);
                    self.perYearUnique(date_year,1,tag_ident)
                    self.perYear(date_year,1,distanceCalculated)
                    self.distanceByMonth[dt.month-1] = self.distanceByMonth[dt.month-1] + distanceCalculated;
                    self.perYearMonth(date_year,dt.month-1,distanceCalculated)
                    self.checkUniqueMonthly(tag_ident,dt.month-1);
                    self.distanceCovered[1]=self.distanceCovered[1]+distanceCalculated
                    pnt_prev_x[1]=self.coordinatesX[1];
                    pnt_prev_y[1]=self.coordinatesY[1];
                if tag_ident not in self.tags:
                    self.uniqueOwls[1] = self.uniqueOwls[1]+1;
                    self.tags.append(tag_ident)
                    self.seasonsText.append('spring')
                self.speedSum[1] = self.speedSum[1] + speed
            else: #autumn
                if self.startTimeStamp[3] == '':
                    self.startTimeStamp[3]=tag_timestamp;
                else:
                    self.endTimeStamp[3]=tag_timestamp;
                self.owlsType[3] = self.owlsType[3]+1
                self.coordinatesX[3] = pnt_now_x;
                self.coordinatesY[3] = pnt_now_y;
                if pnt_prev_x[3]==0:
                    pnt_prev_x[3]=pnt_intial_x;
                    pnt_prev_y[3]=pnt_intial_y;
                else:
                    distanceCalculated = self.calculateDistance(pnt_prev_x[3],pnt_prev_y[3],self.coordinatesX[3],self.coordinatesY[3]);
                    self.perYearUnique(date_year,3,tag_ident)
                    self.perYear(date_year,3,distanceCalculated)
                    self.distanceByMonth[dt.month-1] = self.distanceByMonth[dt.month-1] + distanceCalculated;
                    self.checkUniqueMonthly(tag_ident,dt.month-1);
                    self.perYearMonth(date_year,dt.month-1,distanceCalculated)
                    self.distanceCovered[3]=self.distanceCovered[3]+self.calculateDistance(pnt_prev_x[3],pnt_prev_y[3],self.coordinatesX[3],self.coordinatesY[3])
                    pnt_prev_x[3]=self.coordinatesX[3];
                    pnt_prev_y[3]=self.coordinatesY[3];
                if tag_ident not in self.tags:
                    self.uniqueOwls[3] = self.uniqueOwls[3]+1
                    self.tags.append(tag_ident)
                    self.seasonsText.append('autumn')
                self.speedSum[3] = self.speedSum[3] + speed
            #print(self.distanceCovered)
        #print(str(pnt_now_x)+" "+str(pnt_now_y))